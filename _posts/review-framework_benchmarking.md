---
published: false
layout: post
permalink: /article/stop_benchmarking_frameworks
title: Stop Benchmarking Frameworks
---

We are obsessed with fast. The large players has shown us that [Amazon gets 1% more revenue for every 100ms they save](http://www.strangeloopnetworks.com/resources/infographics/web-performance-and-ecommerce/amazon-100ms-faster-1-revenue-increase/), [Google ranks your site accounting for speed](http://googlewebmastercentral.blogspot.com/2010/04/using-site-speed-in-web-search-ranking.html), and we've been able to [strongly correlate page performance to engagement](http://googleresearch.blogspot.com/2009/06/speed-matters.html). However, I've been involved in an increasing number of unsettling conversations. In these conversations, entire frameworks are being considered or discarded based on benchmarking. I believe we've reached a point where our obsession with "fast" is clouding our ability to make rational decisions.

## First, It's Rarely Apples
There's nothing as simple as [hello world](http://simple.wikipedia.org/wiki/Hello_world_program), right? Let's grab all the things we want to compare, put together a simple "hello world" example for them, load them up in our benchmarking tool and compare. Whatever is the fastest or has the most operations per second (one of our favorite phrases as JavaScript developers) is clearly the best, right? As long as you're in the department of building hello worlds, this makes sense.

The things we build for the web are rarely just a hello world, however. Applications are full of rich interaction, motion, and often employ multiple patterns to accomplish their UI goals. It is in this development of the application, using each framework's unique patterns, that the implementations will drift apart. This is because every framework brings their own philosophy around code organization, development, and patterns. [This benchmark from the Vue.js team](http://vuejs.org/perf/) is a perfect example of the fatal comparison. Looking at pretty graphs, you'd be led to believe that Vue is twice as fast as the next framework and 5x faster than Angular or Ember.

## Second, Confounding Hates You (maybe)
[Confounding](https://explorable.com/confounding-variables) is here to ruin your benchmarks. In its simplest terms, confounding describes a "third variable" that may be impacting your experiment. In our above framework comparison, we said that Vue was faster. However, a quick look at the model and template design of the Ember ([model](https://github.com/tastejs/todomvc/blob/gh-pages/architecture-examples/emberjs/js/models/todo.js) / [tmpl](https://github.com/tastejs/todomvc/blob/gh-pages/architecture-examples/emberjs/index.html)) and Vue ([model](https://github.com/tastejs/todomvc/blob/gh-pages/labs/architecture-examples/vue/js/store.js) / [tmpl](https://github.com/tastejs/todomvc/blob/gh-pages/labs/architecture-examples/vue/index.html)) code reveal two completely different philosophies around data storage and template design. The application design, the boilerplate code, and the templating library are all conspiring together to confound your results.

Another way of looking at this would be this jsPerf [comparing jQuery to DOM](http://jsperf.com/look-how-slow-jquery-is). Unsurprisingly, a native DOM method is a whole 20x faster than jQuery. But, you also have **the entire jQuery library** confounding your experiment. A better test would be testing Sizzle, and an even better test would be testing the code path that Sizzle selects when it detects the selector in question is an ID. All that extra "cost" is providing a hard to measure attribute: usability.

## What You're After: Usability
Our jQuery example above speaks to a hard to capture element of software, the developer usability. The ability to grow your team, minimize the your code footprint, and keep the majority of your codebase searchable in Stack Overflow and Google is one of those traits that isn't considered in the selection of a framework or library. Having watched the team here at LinkedIn from 10x its original size, I've seen first hand the compounding problem of bad APIs. Developers are lazy, and like water, will find the path of least resistence to the solution. It's not because we set out to write bad code, but because we set out to build a feature. Given the problems with the benchmarks we talked about earlier, it stands that a highly opinionated API is more valuable than the performance metrics. So, if you want to do right by your team, select a framework based on how it's API and philosophy align with the project you're building.

You can always make it faster.
